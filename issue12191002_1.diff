# HG changeset patch
# User CÃ©dric Krier <cedric.krier@b2ck.com>
Fix rounding issue in Uom.round


issue4816
review12191002

Index: trytond/trytond/modules/product/tests/test_product.py
===================================================================

--- a/trytond/trytond/modules/product/tests/test_product.py
+++ b/trytond/trytond/modules/product/tests/test_product.py
@@ -6,6 +6,7 @@
 from trytond.tests.test_tryton import ModuleTestCase
 from trytond.tests.test_tryton import POOL, DB_NAME, USER, CONTEXT
 from trytond.transaction import Transaction
+from trytond.pool import Pool
 
 
 class ProductTestCase(ModuleTestCase):
@@ -253,6 +254,26 @@
                     ('template.category', '=', category2.id),
                     ], count=True), 2)
 
+    def test_uom_round(self):
+        'Test uom round function'
+        tests = [
+            (2.53, .1, 2.5),
+            (3.8, .1, 3.8),
+            (3.7, .1, 3.7),
+            (1.3, .5, 1.5),
+            (1.1, .3, 1.2),
+            (17, 10, 20),
+            (7, 10, 10),
+            (4, 10, 0),
+            (17, 15, 15),
+            (2.5, 1.4, 2.8),
+            ]
+        with Transaction().start(DB_NAME, USER, context=CONTEXT):
+            pool = Pool()
+            Uom = pool.get('product.uom')
+            for number, precision, result in tests:
+                self.assertEqual(Uom.round(number, precision), result)
+
 
 def suite():
     suite = trytond.tests.test_tryton.suite()

Index: trytond/trytond/modules/product/uom.py
===================================================================

--- a/trytond/trytond/modules/product/uom.py
+++ b/trytond/trytond/modules/product/uom.py
@@ -1,5 +1,6 @@
 #This file is part of Tryton.  The COPYRIGHT file at the top level of
 #this repository contains the full copyright notices and license terms.
+from __future__ import division
 from decimal import Decimal
 from sql import Table
 
@@ -134,7 +135,11 @@
 
     @staticmethod
     def round(number, precision=1.0):
-        return round(number / precision) * precision
+        i, d = divmod(precision, 1)
+        base = round(number / precision)
+        # Instead of multiply by the decimal part, we must divide by the
+        # integer to avoid precision lost due to float
+        return (base * i) + ((base / (1 / d)) if d != 0 else 0)
 
     @classmethod
     def validate(cls, uoms):

