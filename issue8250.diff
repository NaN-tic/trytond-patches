diff --git a/sao/src/model.js b/sao/src/model.js
index 7f6a6229e6..3536b5264a 100644
--- a/sao/src/model.js
+++ b/sao/src/model.js
@@ -721,7 +721,8 @@
                     ((fdescription.loading || 'lazy') == 'eager')) {
                     fnames_to_fetch.push(fname + ':string');
                 } else if (
-                    ['many2many', 'one2many'].includes(fdescription.type)) {
+                    ['many2many', 'one2many'].includes(fdescription.type) &&
+                    (loading == 'lazy')) {
                     var sub_fields = get_x2m_sub_fields(fdescription, fname);
                     fnames_to_fetch = [ ...fnames_to_fetch, ...sub_fields];
                     if (sub_fields.length > 0) {
diff --git a/trytond/trytond/model/modelsql.py b/trytond/trytond/model/modelsql.py
index 4cfa48db07..7eca2de006 100644
--- a/trytond/trytond/model/modelsql.py
+++ b/trytond/trytond/model/modelsql.py
@@ -1280,6 +1280,8 @@ class ModelSQL(ModelStorage):
                 if value is not None:
                     add(value)
             related_read_limit = transaction.context.get('related_read_limit')
+            # use dict keys to make target ids unique but preserving the order
+            target_ids = list(dict.fromkeys(target_ids).keys())
             rows = Target.read(target_ids[:related_read_limit], fields)
             if related_read_limit is not None:
                 rows += [{'id': i} for i in target_ids[related_read_limit:]]
